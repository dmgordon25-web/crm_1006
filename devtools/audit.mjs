#!/usr/bin/env node
// Minimal, dependency-free static audit for this SPA codebase.
// Produces JSON + Markdown under docs/generated.

import { readFile, mkdir, writeFile } from 'node:fs/promises';
import { dirname, join, relative } from 'node:path';
import { fileURLToPath } from 'node:url';
import { walk } from './utils/fswalk.mjs';

const __DIR = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__DIR, '..');
const SRC = join(ROOT, 'crm-app', 'js');
const OUT = join(ROOT, 'docs', 'generated');

async function ensureDir(p){ try{ await mkdir(p, { recursive:true }); }catch{} }

const RGX = {
  import: /import[\s\S]*?from\s+['"](.+?)['"]/g,
  exportName: /export\s+(?:default\s+)?(?:async\s+)?(?:function|class|const|let)\s+([A-Za-z0-9_$]+)/g,
  exportNamed: /export\s*\{([^}]+)\}/g,
  events_add: /addEventListener\s*\(\s*['"]([^'"]+)['"]/g,
  events_new: /new\s+CustomEvent\s*\(\s*['"]([^'"]+)['"]/g,
  events_dispatch: /dispatchEvent\s*\(\s*new\s+CustomEvent\s*\(\s*['"]([^'"]+)['"]/g,
  renderGuard: /RenderGuard\.(registerHook|requestRender)\s*\(/g,
  renderAll: /window\.renderAll\s*\(/g,
  localStorage: /localStorage\.(?:getItem|setItem)\(\s*['"]([^'"]+)['"]/g,
  moduleFallbackLog: /loader:\s*fallback-inject\s*\{\s*path:\s*.*?,\s*as:\s*'module'\s*\}/,
  selectionChanged: /['"]selection:changed['"]/g,
  dataChanged: /['"]app:data:changed['"]/g,
};

function uniq(arr){ return Array.from(new Set(arr)); }
function pickAll(re, text){ const out=[]; let m; while ((m=re.exec(text))) out.push(m[1]??m[0]); return out; }
function pickAllGroups(re, text){ const out=[]; let m; while ((m=re.exec(text))) out.push(m[1]); return out; }

async function analyzeFile(path){
  const rel = relative(ROOT, path);
  const code = await readFile(path, 'utf8');
  const imports = pickAll(RGX.import, code);
  const exports = uniq([
    ...pickAllGroups(RGX.exportName, code),
    ...pickAllGroups(RGX.exportNamed, code).flatMap(s=>s.split(',').map(x=>x.trim().split(/\s+as\s+/)[1]||x.trim()))
  ]).filter(Boolean);

  const ev_add = pickAllGroups(RGX.events_add, code);
  const ev_new = pickAllGroups(RGX.events_new, code);
  const ev_disp = pickAllGroups(RGX.events_dispatch, code);
  const events = uniq([...ev_add, ...ev_new, ...ev_disp]);

  const render = {
    usesRenderGuard: RGX.renderGuard.test(code),
    callsRenderAll: RGX.renderAll.test(code),
  };

  const storageKeys = pickAllGroups(RGX.localStorage, code);
  const hasModuleFallbackLog = RGX.moduleFallbackLog.test(code);
  const mentionsSelectionChanged = RGX.selectionChanged.test(code);
  const mentionsDataChanged = RGX.dataChanged.test(code);

  return {
    file: rel, imports, exports, events,
    render,
    storageKeys: uniq(storageKeys),
    flags: { hasModuleFallbackLog, mentionsSelectionChanged, mentionsDataChanged },
  };
}

async function run(){
  await ensureDir(OUT);
  const files = [];
  for await (const p of walk(SRC, { ignore: ['node_modules', '/devtools/', '/docs/'] })) files.push(p);

  const analyses = [];
  for (const p of files) analyses.push(await analyzeFile(p));

  // Indexes
  const eventMap = {};
  const storageKeyMap = {};
  const importGraph = {};
  const renderUsage = { usesRenderGuard: [], callsRenderAll: [] };

  for (const a of analyses){
    for (const e of a.events){ (eventMap[e] ||= []).push(a.file); }
    for (const k of a.storageKeys){ (storageKeyMap[k] ||= []).push(a.file); }
    importGraph[a.file] = a.imports;
    if (a.render.usesRenderGuard) renderUsage.usesRenderGuard.push(a.file);
    if (a.render.callsRenderAll) renderUsage.callsRenderAll.push(a.file);
  }

  // Write JSON
  await writeFile(join(OUT, 'module_inventory.json'), JSON.stringify(analyses, null, 2));
  await writeFile(join(OUT, 'event_map.json'), JSON.stringify(eventMap, null, 2));
  await writeFile(join(OUT, 'storage_keys.json'), JSON.stringify(storageKeyMap, null, 2));
  await writeFile(join(OUT, 'import_graph.json'), JSON.stringify(importGraph, null, 2));
  await writeFile(join(OUT, 'render_usage.json'), JSON.stringify(renderUsage, null, 2));

  // Write Markdown summaries
  const mdHeader = (t)=>`# ${t}\n\nGenerated by devtools/audit.mjs\n\n`;

  const modMd = [mdHeader('Module Inventory'),
    '| File | Exports | Events | Storage Keys | Render Hooks |',
    '|---|---|---|---|---|',
    ...analyses.map(a=>`| ${a.file} | ${a.exports.join(', ')||'—'} | ${a.events.join(', ')||'—'} | ${a.storageKeys.join(', ')||'—'} | ${a.render.usesRenderGuard?'RenderGuard ':''}${a.render.callsRenderAll?'renderAll':''} |`)
  ].join('\n');
  await writeFile(join(OUT, 'module_inventory.md'), modMd);

  const evMd = [mdHeader('Event Catalog (found in source)'),
    ...Object.entries(eventMap).sort().map(([ev, files])=>
      `## ${ev}\n\nFound in:\n${files.map(f=>`- ${f}`).join('\n')}\n`)
  ].join('\n');
  await writeFile(join(OUT, 'event_catalog.md'), evMd);

  const stMd = [mdHeader('LocalStorage Keys'),
    ...Object.entries(storageKeyMap).sort().map(([k, files])=>
      `## ${k}\n\nUsed in:\n${files.map(f=>`- ${f}`).join('\n')}\n`)
  ].join('\n');
  await writeFile(join(OUT, 'storage_keys.md'), stMd);

  const rdMd = [mdHeader('Render & Scheduling Usage'),
    '## RenderGuard.registerHook\n', ...renderUsage.usesRenderGuard.map(f=>`- ${f}`),
    '\n\n## window.renderAll calls\n', ...renderUsage.callsRenderAll.map(f=>`- ${f}`)
  ].join('\n');
  await writeFile(join(OUT, 'render_usage.md'), rdMd);

  console.log(`Wrote docs to ${relative(ROOT, OUT)}`);
}

run().catch(err=>{ console.error(err); process.exit(1); });
